// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "matrix-product",
  title: "Matrix Product — Rosetta Pack",
  tags: ["linalg"],
  snippets: [
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — Cuda",
      code: String.raw`// Rust-CUDA (nvptx) target expected
//! Requires rustc_codegen_nvvm / rust-cuda crates in your project.
use core::f64;

#[kernel] // from rust-cuda or accel-like crates
pub unsafe fn matrix_product_kernel(a: *const f64, b: *const f64, c: *mut f64, n: i32, k: i32, m: i32) {
    let i = (block_idx_y() * block_dim_y() + thread_idx_y()) as i32;
    let j = (block_idx_x() * block_dim_x() + thread_idx_x()) as i32;
    if i < n && j < m {
        let mut s = 0.0f64;
        let mut kk = 0;
        while kk < k {
            s += *a.offset((i*k + kk) as isize) * *b.offset((kk*m + j) as isize);
            kk += 1;
        }
        *c.offset((i*m + j) as isize) = s;
    }
}

fn simple_product_sum(b: Vec<f64>, c: Vec<f64>, y: Vec<f64>, m: f64, n: f64, j: f64) -> f64 {
    let mut product = 1;
    let mut i: i64 = 0;
    while i < m {
        product = (product * ((b)[((i * n) + j) as usize] * (c)[((i * n) + j) as usize]));
        i += 1;
    }
    let mut sum = 0;
    let mut k: i64 = 0;
    while k < (y).len() {
        sum = (sum + (y)[k as usize]);
        k += 1;
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-Rust-Simple",
      language: "Rust",
      variant: "Simple",
      title: "Rust — Simple",
      code: String.raw`// expects math_runtime module with MathRt functions
use std::f64;
mod math_runtime;
use math_runtime::*;

fn simple_product_sum(b: Vec<f64>, c: Vec<f64>, y: Vec<f64>, m: f64, n: f64, j: f64) -> f64 {
    let mut product = 1;
    let mut i: i64 = 0;
    while i < m {
        product = (product * ((b)[((i * n) + j) as usize] * (c)[((i * n) + j) as usize]));
        i += 1;
    }
    let mut sum = 0;
    let mut k: i64 = 0;
    while k < (y).len() {
        sum = (sum + (y)[k as usize]);
        k += 1;
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — Cuda",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

def simple_product_sum(b, c, y, m, n, j):
    product = 1
    for i in range(0, m):
        product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]))
    sum = 0
    for k in range(0, len(y)):
        sum = (sum + (y)[k])
    return (product * sum)

`
    }
  ],
};
