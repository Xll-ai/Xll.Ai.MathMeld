// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "black-scholes",
  title: "Black–Scholes (1973) — Rosetta Pack",
  tags: ["finance", "closed-form"],
  snippets: [
    {
      id: "tpl-C-Simple",
      language: "C",
      variant: "Simple",
      title: "C — Simple",
      code: String.raw`// expects math_runtime.h to define erf_impl, cdf_impl, print_fixed
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "math_runtime.h"

int main(void) {
    double S = 100, K = 100, T = 1, r = 0.05, v = 0.2,
        d1 = ((log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * sqrt(T))),
        d2 = (d1 - (v * sqrt(T)));
    print_fixed(((S * cdf_impl(d1)) - (K * (exp((-(r * T))) * cdf_impl(d2)))));
    return 0;
}
`
    },
    {
      id: "tpl-CPlusPlus-Simple",
      language: "CPlusPlus",
      variant: "Simple",
      title: "CPlusPlus — Simple",
      code: String.raw`#include <cmath>
#include <cstddef>
int main() {
    auto S = 100;
    auto K = 100;
    auto T = 1;
    auto r = 0.05;
    auto v = 0.2;
    auto d1 = ((log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * sqrt(T)));
    auto d2 = (d1 - (v * sqrt(T)));
    print_fixed(((S * cdf(d1)) - (K * (exp((-(r * T))) * cdf(d2)))));
    return 0;
}
`
    },
    {
      id: "tpl-CSharp-Simple",
      language: "CSharp",
      variant: "Simple",
      title: "CSharp — Simple",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static void Main(){
    double S = 100;
    double K = 100;
    double T = 1;
    double r = 0.05;
    double v = 0.2;
    double d1 = ((Math.Log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * Math.Sqrt(T)));
    double d2 = (d1 - (v * Math.Sqrt(T)));
    double price = ((S * MathRt.Cdf(d1)) - (K * (Math.Exp((-(r * T))) * MathRt.Cdf(d2))));
    Console.WriteLine(MathRt.PrintFixed(price));
  }
}
`
    },
    {
      id: "tpl-CSharp-TensorMatrixMath",
      language: "CSharp",
      variant: "TensorMatrixMath",
      title: "CSharp — TensorMatrixMath",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static void Main(){
    double S = 100;
    double K = 100;
    double T = 1;
    double r = 0.05;
    double v = 0.2;
    double d1 = ((Math.Log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * Math.Sqrt(T)));
    double d2 = (d1 - (v * Math.Sqrt(T)));
    double price = ((S * MathRt.Cdf(d1)) - (K * (Math.Exp((-(r * T))) * MathRt.Cdf(d2))));
    Console.WriteLine(MathRt.PrintFixed(price));
  }
}
`
    },
    {
      id: "tpl-Go-Simple",
      language: "Go",
      variant: "Simple",
      title: "Go — Simple",
      code: String.raw`package main

// expects mathruntime package with Erf, Cdf, PrintFixed, Powi, DotProduct, VectorNorm
import (
    "math"
    "./mathruntime"
)

func main() {
    var (
        S = 100
        K = 100
        T = 1
        r = 0.05
        v = 0.2
d1 = ((math.Log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * math.Sqrt(T)))
        d2 = (d1 - (v * math.Sqrt(T)))
    )
    mathruntime.PrintFixed (((S * mathruntime.Cdf (d1)) - (K * (math.Exp ((- (r
         * T))) * mathruntime.Cdf (d2)))))
}
`
    },
    {
      id: "tpl-Java-Simple",
      language: "Java",
      variant: "Simple",
      title: "Java — Simple",
      code: String.raw`// expects MathRuntime class with static methods erf, cdf, printFixed
import java.util.*;
import java.lang.Math;

public class GeneratedMath {
    public static void main(String[] args) {
        double S = 100.0;
        double K = 100.0;
        double T = 1.0;
        double r = 0.05;
        double v = 0.2;
        doubled1 = ((Math.log ((S / K)) + ((r + ((v * v) / 2.0)) * T)) / (v *
             Math.sqrt (T)));
        double d2 = (d1 - (v * Math.sqrt(T)));
        MathRuntime.printFixed (((S * MathRuntime.cdf (d1)) - (K * (Math.exp ((-
             (r * T))) * MathRuntime.cdf (d2)))));
    }
}
`
    },
    {
      id: "tpl-Javascript-Simple",
      language: "Javascript",
      variant: "Simple",
      title: "Javascript — Simple",
      code: String.raw`// expects math_runtime.js to define global MathRt {erf,cdf,printFixed}
let S = 100, K = 100, T = 1, r = 0.05, v = 0.2,
    d1 = ((Math.log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * Math.sqrt(T))),
    d2 = (d1 - (v * Math.sqrt(T)));
MathRt.printFixed (((S * MathRt.cdf (d1)) - (K * (Math.exp ((- (r * T))) *
     MathRt.cdf (d2)))));
`
    },
    {
      id: "tpl-MathJax-Simple",
      language: "MathJax",
      variant: "Simple",
      title: "MathJax — Simple",
      code: String.raw`\begin{align*}
    \mathrm{S} &= 100 \\
    \mathrm{K} &= 100 \\
    \mathrm{T} &= 1 \\
    \mathrm{r} &= 0.05 \\
    \mathrm{v} &= 0.2 \\
    \mathrm{d}_{1} &= \frac{\log\left(\frac{\mathrm{S}}{\mathrm{K}}\right) \\ 
&\quad + \mathrm{r} \\ 
&\quad + \frac{\mathrm{v} \\ 
&\quad \cdot \mathrm{v}}{2} \\ 
&\quad \cdot \mathrm{T}}{\mathrm{v} \\ 
&\quad \cdot \sqrt{\mathrm{T}}} \\
    \mathrm{d}_{2} &= \mathrm{d}_{1} - \mathrm{v} \cdot \sqrt{\mathrm{T}} \\
    \mathrm{price} &= \mathrm{S} \\ 
&\quad \cdot \Phi\left(\mathrm{d}_{1}\right) \\ 
&\quad - \mathrm{K} \\ 
&\quad \cdot \exp\left(-\left(\mathrm{r} \\ 
&\quad \cdot \mathrm{T}\right)\right) \\ 
&\quad \cdot \Phi\left(\mathrm{d}_{2}\right) \\
\end{align*}
`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — Cuda",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

if __name__ == '__main__':
    S = 100
    K = 100
    T = 1
    r = 0.05
    v = 0.2
    d1 = ((xp.log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * xp.sqrt(T)))
    d2 = (d1 - (v * xp.sqrt(T)))
    MathRt.print_fixed (((S * MathRt.cdf (d1)) - (K * (xp.exp ((- (r * T))) *
         MathRt.cdf (d2)))))
`
    },
    {
      id: "tpl-Python-Simple",
      language: "Python",
      variant: "Simple",
      title: "Python — Simple",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

if __name__ == '__main__':
    S = 100
    K = 100
    T = 1
    r = 0.05
    v = 0.2
    d1 = ((math.log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * math.sqrt(T)))
    d2 = (d1 - (v * math.sqrt(T)))
    MathRt.print_fixed (((S * MathRt.cdf (d1)) - (K * (math.exp ((- (r * T))) *
         MathRt.cdf (d2)))))
`
    },
    {
      id: "tpl-Python-TensorMatrixMath",
      language: "Python",
      variant: "TensorMatrixMath",
      title: "Python — TensorMatrixMath",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

if __name__ == '__main__':
    S = 100
    K = 100
    T = 1
    r = 0.05
    v = 0.2
    d1 = ((math.log((S / K)) + ((r + ((v * v) / 2)) * T)) / (v * math.sqrt(T)))
    d2 = (d1 - (v * math.sqrt(T)))
    MathRt.print_fixed (((S * MathRt.cdf (d1)) - (K * (math.exp ((- (r * T))) *
         MathRt.cdf (d2)))))
`
    },
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — Cuda",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn main() {
    let mut S = 100;
    let mut K = 100;
    let mut T = 1;
    let mut r = 0.05;
    let mut v = 0.2;
    let mut d1 = ((((S / K)).ln() + ((r + ((v * v) / 2)) * T)) / (v * (T).sqrt()));
    let mut d2 = (d1 - (v * (T).sqrt()));
    let mut price = ((S * cdf(d1)) - (K * (((-(r * T))).exp() * cdf(d2))));
    println!("{}", price);
}
`
    },
    {
      id: "tpl-Rust-Simple",
      language: "Rust",
      variant: "Simple",
      title: "Rust — Simple",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn main() {
    let mut S = 100;
    let mut K = 100;
    let mut T = 1;
    let mut r = 0.05;
    let mut v = 0.2;
    let mut d1 = ((((S / K)).ln() + ((r + ((v * v) / 2)) * T)) / (v * (T).sqrt()));
    let mut d2 = (d1 - (v * (T).sqrt()));
    let mut price = ((S * cdf(d1)) - (K * (((-(r * T))).exp() * cdf(d2))));
    println!("{}", price);
}
`
    },
    {
      id: "tpl-Rust-TensorMatrixMath",
      language: "Rust",
      variant: "TensorMatrixMath",
      title: "Rust — TensorMatrixMath",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn main() {
    let mut S = 100;
    let mut K = 100;
    let mut T = 1;
    let mut r = 0.05;
    let mut v = 0.2;
    let mut d1 = ((((S / K)).ln() + ((r + ((v * v) / 2)) * T)) / (v * (T).sqrt()));
    let mut d2 = (d1 - (v * (T).sqrt()));
    let mut price = ((S * cdf(d1)) - (K * (((-(r * T))).exp() * cdf(d2))));
    println!("{}", price);
}
`
    }
  ]
};
