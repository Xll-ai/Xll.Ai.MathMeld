// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "Svensson curve — discount factor (Svensson parametrization)",
  title: "",
  tags: ["finance", "closed-form"],
  snippets: [
    {
      id: "tpl-C-Simple",
      language: "C",
      variant: "Simple",
      title: "C — Simple",
      code: String.raw`// expects math_runtime.h to define erf_impl, cdf_impl, print_fixed
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "math_runtime.h"

double svensson_interpolate(double time, double beta1, double beta2,
                            double beta3, double beta4, double tau1, double tau2,
                            double time_ratio);

double svensson_interpolate(double time, double beta1, double beta2,
                            double beta3, double beta4, double tau1, double tau2,
                            double time_ratio {
    double eps_time = 1E-05, t = (time / time_ratio),
        time_over_tau1 = (t / tau1), time_over_tau2 = (t / tau2),
        exp_tau1 = exp((0 - time_over_tau1)),
        exp_tau2 = exp((0 - time_over_tau2)),
        term_tau1_frac = ((1 - exp_tau1) / time_over_tau1),
        term_tau2_frac = ((1 - exp_tau2) / time_over_tau2), comp1 = beta1,
        comp2 = (beta2 * term_tau1_frac),
        comp3_inner = (term_tau1_frac - exp_tau1), comp3 = (beta3 * comp3_inner),
        comp4_inner = (term_tau2_frac - exp_tau2), comp4 = (beta4 * comp4_inner),
        r = ((comp1 + comp2) + (comp3 + comp4)), inner = (-0.01 * (r * t)),
        result_exp = exp(inner);
    return ((time < eps_time) ? 1 : result_exp);
}

`
    },
    {
      id: "tpl-CPlusPlus-Simple",
      language: "CPlusPlus",
      variant: "Simple",
      title: "CPlusPlus — Simple",
      code: String.raw`#include <cmath>
#include <cstddef>
double svensson_interpolate(double time, double beta1, double beta2,
                            double beta3, double beta4, double tau1, double tau2,
                            double time_ratio) {
    auto eps_time = 1E-05;
    auto t = (time / time_ratio);
    auto time_over_tau1 = (t / tau1);
    auto time_over_tau2 = (t / tau2);
    auto exp_tau1 = exp((0 - time_over_tau1));
    auto exp_tau2 = exp((0 - time_over_tau2));
    auto term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    auto term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    double comp1 = beta1;
    auto comp2 = (beta2 * term_tau1_frac);
    auto comp3_inner = (term_tau1_frac - exp_tau1);
    auto comp3 = (beta3 * comp3_inner);
    auto comp4_inner = (term_tau2_frac - exp_tau2);
    auto comp4 = (beta4 * comp4_inner);
    auto r = ((comp1 + comp2) + (comp3 + comp4));
    auto inner = (-0.01 * (r * t));
    auto result_exp = exp(inner);
    return ((time < eps_time) ? 1 : result_exp);
}

`
    },
    {
      id: "tpl-CSharp-Simple",
      language: "CSharp",
      variant: "Simple",
      title: "CSharp — Simple",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double svensson_interpolate(double time, double beta1, double beta2, double beta3, double beta4, double tau1, double tau2, double time_ratio){
    double eps_time = 1E-05;
    double t = (time / time_ratio);
    double time_over_tau1 = (t / tau1);
    double time_over_tau2 = (t / tau2);
    double exp_tau1 = Math.Exp((0 - time_over_tau1));
    double exp_tau2 = Math.Exp((0 - time_over_tau2));
    double term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    double term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    double comp1 = beta1;
    double comp2 = (beta2 * term_tau1_frac);
    double comp3_inner = (term_tau1_frac - exp_tau1);
    double comp3 = (beta3 * comp3_inner);
    double comp4_inner = (term_tau2_frac - exp_tau2);
    double comp4 = (beta4 * comp4_inner);
    double r = ((comp1 + comp2) + (comp3 + comp4));
    double inner = (-0.01 * (r * t));
    double result_exp = Math.Exp(inner);
    return ((time < eps_time) ? 1 : result_exp);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-CSharp-TensorMatrixMath",
      language: "CSharp",
      variant: "TensorMatrixMath",
      title: "CSharp — TensorMatrixMath",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double svensson_interpolate(double time, double beta1, double beta2, double beta3, double beta4, double tau1, double tau2, double time_ratio){
    double eps_time = 1E-05;
    double t = (time / time_ratio);
    double time_over_tau1 = (t / tau1);
    double time_over_tau2 = (t / tau2);
    double exp_tau1 = Math.Exp((0 - time_over_tau1));
    double exp_tau2 = Math.Exp((0 - time_over_tau2));
    double term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    double term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    double comp1 = beta1;
    double comp2 = (beta2 * term_tau1_frac);
    double comp3_inner = (term_tau1_frac - exp_tau1);
    double comp3 = (beta3 * comp3_inner);
    double comp4_inner = (term_tau2_frac - exp_tau2);
    double comp4 = (beta4 * comp4_inner);
    double r = ((comp1 + comp2) + (comp3 + comp4));
    double inner = (-0.01 * (r * t));
    double result_exp = Math.Exp(inner);
    return ((time < eps_time) ? 1 : result_exp);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-Go-Simple",
      language: "Go",
      variant: "Simple",
      title: "Go — Simple",
      code: String.raw`package main

// expects mathruntime package with Erf, Cdf, PrintFixed, Powi, DotProduct, VectorNorm
import (
    "math"
    "./mathruntime"
)

func svensson_interpolate(time float64, beta1 float64, beta2 float64,
                          beta3 float64, beta4 float64, tau1 float64,
                          tau2 float64, time_ratio float64) float64 {
    var (
        eps_time = 1E-05
        t = (time / time_ratio)
        time_over_tau1 = (t / tau1)
        time_over_tau2 = (t / tau2)
        exp_tau1 float64 = math.Exp((0 - time_over_tau1))
        exp_tau2 float64 = math.Exp((0 - time_over_tau2))
        term_tau1_frac = ((1 - exp_tau1) / time_over_tau1)
        term_tau2_frac = ((1 - exp_tau2) / time_over_tau2)
        comp1 float64 = beta1
        comp2 = (beta2 * term_tau1_frac)
        comp3_inner = (term_tau1_frac - exp_tau1)
        comp3 = (beta3 * comp3_inner)
        comp4_inner = (term_tau2_frac - exp_tau2)
        comp4 = (beta4 * comp4_inner)
        r = ((comp1 + comp2) + (comp3 + comp4))
        inner = (-0.01 * (r * t))
        result_exp float64 = math.Exp(inner)
    )
    return (func () float64{if (time < eps_time) {return1}returnresult_exp} ())
}

`
    },
    {
      id: "tpl-Java-Simple",
      language: "Java",
      variant: "Simple",
      title: "Java — Simple",
      code: String.raw`// expects MathRuntime class with static methods erf, cdf, printFixed
import java.util.*;
import java.lang.Math;

public class GeneratedMath {
    public static double svensson_interpolate(double time, double beta1,
                                              double beta2, double beta3,
                                              double beta4, double tau1,
                                              double tau2, double time_ratio) {
        double eps_time = 1E-05;
        double t = (time / time_ratio);
        double time_over_tau1 = (t / tau1);
        double time_over_tau2 = (t / tau2);
        double exp_tau1 = Math.exp((0.0 - time_over_tau1));
        double exp_tau2 = Math.exp((0.0 - time_over_tau2));
        double term_tau1_frac = ((1.0 - exp_tau1) / time_over_tau1);
        double term_tau2_frac = ((1.0 - exp_tau2) / time_over_tau2);
        double comp1 = beta1;
        double comp2 = (beta2 * term_tau1_frac);
        double comp3_inner = (term_tau1_frac - exp_tau1);
        double comp3 = (beta3 * comp3_inner);
        double comp4_inner = (term_tau2_frac - exp_tau2);
        double comp4 = (beta4 * comp4_inner);
        double r = ((comp1 + comp2) + (comp3 + comp4));
        double inner = (-0.01 * (r * t));
        double result_exp = Math.exp(inner);
        return ((time < eps_time) ? 1.0 : result_exp);
    }

}
`
    },
    {
      id: "tpl-Javascript-Simple",
      language: "Javascript",
      variant: "Simple",
      title: "Javascript — Simple",
      code: String.raw`// expects math_runtime.js to define global MathRt {erf,cdf,printFixed}
function svensson_interpolate(time, beta1, beta2, beta3, beta4, tau1, tau2,
                              time_ratio){
let eps_time = 1E-05;
let t = (time / time_ratio);
let time_over_tau1 = (t / tau1);
let time_over_tau2 = (t / tau2);
let exp_tau1 = Math.exp((0 - time_over_tau1));
let exp_tau2 = Math.exp((0 - time_over_tau2));
let term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
let term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
let comp1 = beta1;
let comp2 = (beta2 * term_tau1_frac);
let comp3_inner = (term_tau1_frac - exp_tau1);
let comp3 = (beta3 * comp3_inner);
let comp4_inner = (term_tau2_frac - exp_tau2);
let comp4 = (beta4 * comp4_inner);
let r = ((comp1 + comp2) + (comp3 + comp4));
let inner = (-0.01 * (r * t));
let result_exp = Math.exp(inner);
return ((time < eps_time) ? 1 : result_exp);
}

`
    },
    {
      id: "tpl-MathJax-Simple",
      language: "MathJax",
      variant: "Simple",
      title: "MathJax — Simple",
      code: String.raw`\begin{align*}
\end{align*}
`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — Cuda",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

def svensson_interpolate(time, beta1, beta2, beta3, beta4, tau1, tau2,
                         time_ratio):
    eps_time = 1E-05
    t = (time / time_ratio)
    time_over_tau1 = (t / tau1)
    time_over_tau2 = (t / tau2)
    exp_tau1 = xp.exp((0 - time_over_tau1))
    exp_tau2 = xp.exp((0 - time_over_tau2))
    term_tau1_frac = ((1 - exp_tau1) / time_over_tau1)
    term_tau2_frac = ((1 - exp_tau2) / time_over_tau2)
    comp1 = beta1
    comp2 = (beta2 * term_tau1_frac)
    comp3_inner = (term_tau1_frac - exp_tau1)
    comp3 = (beta3 * comp3_inner)
    comp4_inner = (term_tau2_frac - exp_tau2)
    comp4 = (beta4 * comp4_inner)
    r = ((comp1 + comp2) + (comp3 + comp4))
    inner = (-0.01 * (r * t))
    result_exp = xp.exp(inner)
    return (xp.where((time < eps_time), 1, result_exp))

`
    },
    {
      id: "tpl-Python-Simple",
      language: "Python",
      variant: "Simple",
      title: "Python — Simple",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def svensson_interpolate(time, beta1, beta2, beta3, beta4, tau1, tau2,
                         time_ratio):
    eps_time = 1E-05
    t = (time / time_ratio)
    time_over_tau1 = (t / tau1)
    time_over_tau2 = (t / tau2)
    exp_tau1 = math.exp((0 - time_over_tau1))
    exp_tau2 = math.exp((0 - time_over_tau2))
    term_tau1_frac = ((1 - exp_tau1) / time_over_tau1)
    term_tau2_frac = ((1 - exp_tau2) / time_over_tau2)
    comp1 = beta1
    comp2 = (beta2 * term_tau1_frac)
    comp3_inner = (term_tau1_frac - exp_tau1)
    comp3 = (beta3 * comp3_inner)
    comp4_inner = (term_tau2_frac - exp_tau2)
    comp4 = (beta4 * comp4_inner)
    r = ((comp1 + comp2) + (comp3 + comp4))
    inner = (-0.01 * (r * t))
    result_exp = math.exp(inner)
    return (1 if (time < eps_time) else result_exp)

`
    },
    {
      id: "tpl-Python-TensorMatrixMath",
      language: "Python",
      variant: "TensorMatrixMath",
      title: "Python — TensorMatrixMath",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def svensson_interpolate(time, beta1, beta2, beta3, beta4, tau1, tau2,
                         time_ratio):
    eps_time = 1E-05
    t = (time / time_ratio)
    time_over_tau1 = (t / tau1)
    time_over_tau2 = (t / tau2)
    exp_tau1 = math.exp((0 - time_over_tau1))
    exp_tau2 = math.exp((0 - time_over_tau2))
    term_tau1_frac = ((1 - exp_tau1) / time_over_tau1)
    term_tau2_frac = ((1 - exp_tau2) / time_over_tau2)
    comp1 = beta1
    comp2 = (beta2 * term_tau1_frac)
    comp3_inner = (term_tau1_frac - exp_tau1)
    comp3 = (beta3 * comp3_inner)
    comp4_inner = (term_tau2_frac - exp_tau2)
    comp4 = (beta4 * comp4_inner)
    r = ((comp1 + comp2) + (comp3 + comp4))
    inner = (-0.01 * (r * t))
    result_exp = math.exp(inner)
    return (1 if (time < eps_time) else result_exp)

`
    },
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — Cuda",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn svensson_interpolate(time: f64, beta1: f64, beta2: f64, beta3: f64,
                        beta4: f64, tau1: f64, tau2: f64, time_ratio: f64) -> f64 {
    let mut eps_time = 1E-05;
    let mut t = (time / time_ratio);
    let mut time_over_tau1 = (t / tau1);
    let mut time_over_tau2 = (t / tau2);
    let mut exp_tau1: f64 = ((0 - time_over_tau1)).exp();
    let mut exp_tau2: f64 = ((0 - time_over_tau2)).exp();
    let mut term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    let mut term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    let mut comp1: f64 = beta1;
    let mut comp2 = (beta2 * term_tau1_frac);
    let mut comp3_inner = (term_tau1_frac - exp_tau1);
    let mut comp3 = (beta3 * comp3_inner);
    let mut comp4_inner = (term_tau2_frac - exp_tau2);
    let mut comp4 = (beta4 * comp4_inner);
    let mut r = ((comp1 + comp2) + (comp3 + comp4));
    let mut inner = (-0.01 * (r * t));
    let mut result_exp: f64 = (inner).exp();
    return (if (time < eps_time) { 1 } else { result_exp });
}

`
    },
    {
      id: "tpl-Rust-Simple",
      language: "Rust",
      variant: "Simple",
      title: "Rust — Simple",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn svensson_interpolate(time: f64, beta1: f64, beta2: f64, beta3: f64,
                        beta4: f64, tau1: f64, tau2: f64, time_ratio: f64) -> f64 {
    let mut eps_time = 1E-05;
    let mut t = (time / time_ratio);
    let mut time_over_tau1 = (t / tau1);
    let mut time_over_tau2 = (t / tau2);
    let mut exp_tau1: f64 = ((0 - time_over_tau1)).exp();
    let mut exp_tau2: f64 = ((0 - time_over_tau2)).exp();
    let mut term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    let mut term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    let mut comp1: f64 = beta1;
    let mut comp2 = (beta2 * term_tau1_frac);
    let mut comp3_inner = (term_tau1_frac - exp_tau1);
    let mut comp3 = (beta3 * comp3_inner);
    let mut comp4_inner = (term_tau2_frac - exp_tau2);
    let mut comp4 = (beta4 * comp4_inner);
    let mut r = ((comp1 + comp2) + (comp3 + comp4));
    let mut inner = (-0.01 * (r * t));
    let mut result_exp: f64 = (inner).exp();
    return (if (time < eps_time) { 1 } else { result_exp });
}

`
    },
    {
      id: "tpl-Rust-TensorMatrixMath",
      language: "Rust",
      variant: "TensorMatrixMath",
      title: "Rust — TensorMatrixMath",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn svensson_interpolate(time: f64, beta1: f64, beta2: f64, beta3: f64,
                        beta4: f64, tau1: f64, tau2: f64, time_ratio: f64) -> f64 {
    let mut eps_time = 1E-05;
    let mut t = (time / time_ratio);
    let mut time_over_tau1 = (t / tau1);
    let mut time_over_tau2 = (t / tau2);
    let mut exp_tau1: f64 = ((0 - time_over_tau1)).exp();
    let mut exp_tau2: f64 = ((0 - time_over_tau2)).exp();
    let mut term_tau1_frac = ((1 - exp_tau1) / time_over_tau1);
    let mut term_tau2_frac = ((1 - exp_tau2) / time_over_tau2);
    let mut comp1: f64 = beta1;
    let mut comp2 = (beta2 * term_tau1_frac);
    let mut comp3_inner = (term_tau1_frac - exp_tau1);
    let mut comp3 = (beta3 * comp3_inner);
    let mut comp4_inner = (term_tau2_frac - exp_tau2);
    let mut comp4 = (beta4 * comp4_inner);
    let mut r = ((comp1 + comp2) + (comp3 + comp4));
    let mut inner = (-0.01 * (r * t));
    let mut result_exp: f64 = (inner).exp();
    return (if (time < eps_time) { 1 } else { result_exp });
}

`
    }
  ]
};
