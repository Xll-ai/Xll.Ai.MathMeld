// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "sabr-black-vol",
  title: "SABR (Hagan 2002) implied Black lognormal volatility",
  tags: ["finance", "closed-form"],
  snippets: [
    {
      id: "tpl-C-Simple",
      language: "C",
      variant: "Simple",
      title: "C — Simple",
      code: String.raw`// expects math_runtime.h to define erf_impl, cdf_impl, print_fixed
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "math_runtime.h"

double sabr_implied_black_lognormal_volatility(double forward, double strike,
                                               double t, double alpha,
                                               double beta, double nu,
                                               double rho);

double sabr_implied_black_lognormal_volatility(double forward, double strike,
                                               double t, double alpha,
                                               double beta, double nu,
                                               double rho {
    double rho_min = -0.999999, rho_max = 0.999999,
        rho_clamped = fmax(rho_min, fmin(rho_max, rho)), beta0 = 0, beta1 = 1,
        beta_c = fmax(beta0, fmin(beta1, beta)), omb = (1 - beta_c),
        omb2 = (omb * omb), omb4 = (omb2 * omb2), fk = (forward * strike),
        pfk = pow(fk, (0.5 * omb)), pfk2 = (pfk * pfk),
        lfk = log((forward / strike)), lfk2 = (lfk * lfk), lfk4 = (lfk2 * lfk2),
        z = (((nu / alpha) * pfk) * lfk), eps = 1E-08, absz = fabs(z),
        rad = sqrt(((1 - (2 * (rho_clamped * z))) + (z * z))),
        xz = log((((rad + z) - rho_clamped) / (1 - rho_clamped))),
        sabr2_raw = (z / xz), sabr2 = ((absz < eps) ? 1 : sabr2_raw),
        alpha2 = (alpha * alpha), nu2 = (nu * nu),
        rho2 = (rho_clamped * rho_clamped),
        denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4))),
        sabr1 = (alpha / (pfk * denom)), tc1 = ((omb2 * alpha2) / (24 * pfk2)),
        tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk),
        tc3 = (((2 - (3 * rho2)) * nu2) / 24), timeCorr = ((tc1 + tc2) + tc3),
        sabr3 = (1 + (timeCorr * t)), sigma = (sabr1 * (sabr2 * sabr3));
    return ((t <= 0) ? 0 : sigma);
}

`
    },
    {
      id: "tpl-CPlusPlus-Simple",
      language: "CPlusPlus",
      variant: "Simple",
      title: "CPlusPlus — Simple",
      code: String.raw`#include <cmath>
#include <cstddef>
double sabr_implied_black_lognormal_volatility(double forward, double strike,
                                               double t, double alpha,
                                               double beta, double nu,
                                               double rho) {
    auto rho_min = -0.999999;
    auto rho_max = 0.999999;
    auto rho_clamped = fmax(rho_min, fmin(rho_max, rho));
    auto beta0 = 0;
    auto beta1 = 1;
    auto beta_c = fmax(beta0, fmin(beta1, beta));
    auto omb = (1 - beta_c);
    auto omb2 = (omb * omb);
    auto omb4 = (omb2 * omb2);
    auto fk = (forward * strike);
    auto pfk = pow(fk, (0.5 * omb));
    auto pfk2 = (pfk * pfk);
    auto lfk = log((forward / strike));
    auto lfk2 = (lfk * lfk);
    auto lfk4 = (lfk2 * lfk2);
    auto z = (((nu / alpha) * pfk) * lfk);
    auto eps = 1E-08;
    auto absz = abs(z);
    auto rad = sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)));
    auto xz = log((((rad + z) - rho_clamped) / (1 - rho_clamped)));
    auto sabr2_raw = (z / xz);
    double sabr2 = ((absz < eps) ? 1 : sabr2_raw);
    auto alpha2 = (alpha * alpha);
    auto nu2 = (nu * nu);
    auto rho2 = (rho_clamped * rho_clamped);
    auto denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    auto sabr1 = (alpha / (pfk * denom));
    auto tc1 = ((omb2 * alpha2) / (24 * pfk2));
    auto tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    auto tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    auto timeCorr = ((tc1 + tc2) + tc3);
    auto sabr3 = (1 + (timeCorr * t));
    auto sigma = (sabr1 * (sabr2 * sabr3));
    return ((t <= 0) ? 0 : sigma);
}

`
    },
    {
      id: "tpl-CSharp-Simple",
      language: "CSharp",
      variant: "Simple",
      title: "CSharp — Simple",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double sabr_implied_black_lognormal_volatility(double forward, double strike, double t, double alpha, double beta, double nu, double rho){
    double rho_min = -0.999999;
    double rho_max = 0.999999;
    double rho_clamped = Math.Max(rho_min, Math.Min(rho_max, rho));
    double beta0 = 0;
    double beta1 = 1;
    double beta_c = Math.Max(beta0, Math.Min(beta1, beta));
    double omb = (1 - beta_c);
    double omb2 = (omb * omb);
    double omb4 = (omb2 * omb2);
    double fk = (forward * strike);
    double pfk = Math.Pow(fk, (0.5 * omb));
    double pfk2 = (pfk * pfk);
    double lfk = Math.Log((forward / strike));
    double lfk2 = (lfk * lfk);
    double lfk4 = (lfk2 * lfk2);
    double z = (((nu / alpha) * pfk) * lfk);
    double eps = 1E-08;
    double absz = Math.Abs(z);
    double rad = Math.Sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)));
    double xz = Math.Log((((rad + z) - rho_clamped) / (1 - rho_clamped)));
    double sabr2_raw = (z / xz);
    double sabr2 = ((absz < eps) ? 1 : sabr2_raw);
    double alpha2 = (alpha * alpha);
    double nu2 = (nu * nu);
    double rho2 = (rho_clamped * rho_clamped);
    double denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    double sabr1 = (alpha / (pfk * denom));
    double tc1 = ((omb2 * alpha2) / (24 * pfk2));
    double tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    double tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    double timeCorr = ((tc1 + tc2) + tc3);
    double sabr3 = (1 + (timeCorr * t));
    double sigma = (sabr1 * (sabr2 * sabr3));
    return ((t <= 0) ? 0 : sigma);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-CSharp-TensorMatrixMath",
      language: "CSharp",
      variant: "TensorMatrixMath",
      title: "CSharp — TensorMatrixMath",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double sabr_implied_black_lognormal_volatility(double forward, double strike, double t, double alpha, double beta, double nu, double rho){
    double rho_min = -0.999999;
    double rho_max = 0.999999;
    double rho_clamped = Math.Max(rho_min, Math.Min(rho_max, rho));
    double beta0 = 0;
    double beta1 = 1;
    double beta_c = Math.Max(beta0, Math.Min(beta1, beta));
    double omb = (1 - beta_c);
    double omb2 = (omb * omb);
    double omb4 = (omb2 * omb2);
    double fk = (forward * strike);
    double pfk = Math.Pow(fk, (0.5 * omb));
    double pfk2 = (pfk * pfk);
    double lfk = Math.Log((forward / strike));
    double lfk2 = (lfk * lfk);
    double lfk4 = (lfk2 * lfk2);
    double z = (((nu / alpha) * pfk) * lfk);
    double eps = 1E-08;
    double absz = Math.Abs(z);
    double rad = Math.Sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)));
    double xz = Math.Log((((rad + z) - rho_clamped) / (1 - rho_clamped)));
    double sabr2_raw = (z / xz);
    double sabr2 = ((absz < eps) ? 1 : sabr2_raw);
    double alpha2 = (alpha * alpha);
    double nu2 = (nu * nu);
    double rho2 = (rho_clamped * rho_clamped);
    double denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    double sabr1 = (alpha / (pfk * denom));
    double tc1 = ((omb2 * alpha2) / (24 * pfk2));
    double tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    double tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    double timeCorr = ((tc1 + tc2) + tc3);
    double sabr3 = (1 + (timeCorr * t));
    double sigma = (sabr1 * (sabr2 * sabr3));
    return ((t <= 0) ? 0 : sigma);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-Go-Simple",
      language: "Go",
      variant: "Simple",
      title: "Go — Simple",
      code: String.raw`package main

// expects mathruntime package with Erf, Cdf, PrintFixed, Powi, DotProduct, VectorNorm
import (
    "math"
    "./mathruntime"
)

func sabr_implied_black_lognormal_volatility(forward float64, strike float64,
                                             t float64, alpha float64,
                                             beta float64, nu float64,
                                             rho float64) float64 {
    var (
        rho_min = -0.999999
        rho_max = 0.999999
        rho_clamped float64 = math.Max(rho_min, math.Min(rho_max, rho))
        beta0 = 0
        beta1 = 1
        beta_c float64 = math.Max(beta0, math.Min(beta1, beta))
        omb = (1 - beta_c)
        omb2 = (omb * omb)
        omb4 = (omb2 * omb2)
        fk = (forward * strike)
        pfk float64 = math.Pow(fk, (0.5 * omb))
        pfk2 = (pfk * pfk)
        lfk float64 = math.Log((forward / strike))
        lfk2 = (lfk * lfk)
        lfk4 = (lfk2 * lfk2)
        z = (((nu / alpha) * pfk) * lfk)
        eps = 1E-08
        absz float64 = math.Abs(z)
        rad float64 = math.Sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)))
        xz float64 = math.Log((((rad + z) - rho_clamped) / (1 - rho_clamped)))
        sabr2_raw = (z / xz)
        sabr2float64 = (func () float64{if (absz < eps)
             {return1}returnsabr2_raw} ())
        alpha2 = (alpha * alpha)
        nu2 = (nu * nu)
        rho2 = (rho_clamped * rho_clamped)
        denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)))
        sabr1 = (alpha / (pfk * denom))
        tc1 = ((omb2 * alpha2) / (24 * pfk2))
        tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk)
        tc3 = (((2 - (3 * rho2)) * nu2) / 24)
        timeCorr = ((tc1 + tc2) + tc3)
        sabr3 = (1 + (timeCorr * t))
        sigma = (sabr1 * (sabr2 * sabr3))
    )
    return (func() float64 { if (t <= 0) { return 0 } return sigma }())
}

`
    },
    {
      id: "tpl-Java-Simple",
      language: "Java",
      variant: "Simple",
      title: "Java — Simple",
      code: String.raw`// expects MathRuntime class with static methods erf, cdf, printFixed
import java.util.*;
import java.lang.Math;

public class GeneratedMath {
    public static double sabr_implied_black_lognormal_volatility(double forward,
                                                                 double strike,
                                                                 double t,
                                                                 double alpha,
                                                                 double beta,
                                                                 double nu,
                                                                 double rho) {
        double rho_min = -0.999999;
        double rho_max = 0.999999;
        double rho_clamped = Math.max(rho_min, Math.min(rho_max, rho));
        double beta0 = 0.0;
        double beta1 = 1.0;
        double beta_c = Math.max(beta0, Math.min(beta1, beta));
        double omb = (1.0 - beta_c);
        double omb2 = (omb * omb);
        double omb4 = (omb2 * omb2);
        double fk = (forward * strike);
        double pfk = Math.pow(fk, (0.5 * omb));
        double pfk2 = (pfk * pfk);
        double lfk = Math.log((forward / strike));
        double lfk2 = (lfk * lfk);
        double lfk4 = (lfk2 * lfk2);
        double z = (((nu / alpha) * pfk) * lfk);
        double eps = 1E-08;
        double absz = Math.abs(z);
        double rad = Math.sqrt(((1.0 - (2.0 * (rho_clamped * z))) + (z * z)));
        double xz = Math.log((((rad + z) - rho_clamped) / (1.0 - rho_clamped)));
        double sabr2_raw = (z / xz);
        double sabr2 = ((absz < eps) ? 1.0 : sabr2_raw);
        double alpha2 = (alpha * alpha);
        double nu2 = (nu * nu);
        double rho2 = (rho_clamped * rho_clamped);
double denom = (1.0 + (((omb2 / 24.0) * lfk2) + ((omb4 / 1920.0) * lfk4)));
        double sabr1 = (alpha / (pfk * denom));
        double tc1 = ((omb2 * alpha2) / (24.0 * pfk2));
        double tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
        double tc3 = (((2.0 - (3.0 * rho2)) * nu2) / 24.0);
        double timeCorr = ((tc1 + tc2) + tc3);
        double sabr3 = (1.0 + (timeCorr * t));
        double sigma = (sabr1 * (sabr2 * sabr3));
        return ((t <= 0.0) ? 0.0 : sigma);
    }

}
`
    },
    {
      id: "tpl-Javascript-Simple",
      language: "Javascript",
      variant: "Simple",
      title: "Javascript — Simple",
      code: String.raw`// expects math_runtime.js to define global MathRt {erf,cdf,printFixed}
function sabr_implied_black_lognormal_volatility(forward, strike, t, alpha, beta,
                                                 nu, rho){
let rho_min = -0.999999;
let rho_max = 0.999999;
let rho_clamped = Math.max(rho_min, Math.min(rho_max, rho));
let beta0 = 0;
let beta1 = 1;
let beta_c = Math.max(beta0, Math.min(beta1, beta));
let omb = (1 - beta_c);
let omb2 = (omb * omb);
let omb4 = (omb2 * omb2);
let fk = (forward * strike);
let pfk = Math.pow(fk, (0.5 * omb));
let pfk2 = (pfk * pfk);
let lfk = Math.log((forward / strike));
let lfk2 = (lfk * lfk);
let lfk4 = (lfk2 * lfk2);
let z = (((nu / alpha) * pfk) * lfk);
let eps = 1E-08;
let absz = Math.abs(z);
let rad = Math.sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)));
let xz = Math.log((((rad + z) - rho_clamped) / (1 - rho_clamped)));
let sabr2_raw = (z / xz);
let sabr2 = ((absz < eps) ? 1 : sabr2_raw);
let alpha2 = (alpha * alpha);
let nu2 = (nu * nu);
let rho2 = (rho_clamped * rho_clamped);
let denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
let sabr1 = (alpha / (pfk * denom));
let tc1 = ((omb2 * alpha2) / (24 * pfk2));
let tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
let tc3 = (((2 - (3 * rho2)) * nu2) / 24);
let timeCorr = ((tc1 + tc2) + tc3);
let sabr3 = (1 + (timeCorr * t));
let sigma = (sabr1 * (sabr2 * sabr3));
return ((t <= 0) ? 0 : sigma);
}

`
    },
    {
      id: "tpl-MathJax-Simple",
      language: "MathJax",
      variant: "Simple",
      title: "MathJax — Simple",
      code: String.raw`\begin{align*}
    \mathrm{rho_min} &= -0.999999 \\
    \mathrm{rho_max} &= 0.999999 \\
    \mathrm{rho_clamped} &= \mathrm{max}\left(\mathrm{rho_min} \\ 
&\quad , \mathrm{min}\left(\mathrm{rho_max} \\ 
&\quad , \rho\right)\right) \\
    \mathrm{beta}_{0} &= 0 \\
    \mathrm{beta}_{1} &= 1 \\
    \mathrm{beta_c} &= \mathrm{max}\left(\mathrm{beta}_{0} \\ 
&\quad , \mathrm{min}\left(\mathrm{beta}_{1} \\ 
&\quad , \beta\right)\right) \\
    1-\beta &= 1 - \mathrm{beta_c} \\
    \mathrm{omb}_{2} &= 1-\beta \cdot 1-\beta \\
    \mathrm{omb}_{4} &= \mathrm{omb}_{2} \cdot \mathrm{omb}_{2} \\
    \mathrm{fk} &= F \cdot K \\
    (F K)^{(1-\beta)/2} &= \mathrm{pow}\left(\mathrm{fk} \\ 
&\quad , 0.5 \\ 
&\quad \cdot 1-\beta\right) \\
    \mathrm{pfk}_{2} &= (F K)^{(1-\beta)/2} \cdot (F K)^{(1-\beta)/2} \\
    \log\!\left(\frac{F}{K}\right) &= \log\left(\frac{F}{K}\right) \\
    \mathrm{lfk}_{2} &= \log\!\left(\frac{F}{K}\right) \\ 
&\quad \cdot \log\!\left(\frac{F}{K}\right) \\
    \mathrm{lfk}_{4} &= \mathrm{lfk}_{2} \cdot \mathrm{lfk}_{2} \\
    z &= \frac{\nu}{\alpha} \\ 
&\quad \cdot (F K)^{(1-\beta)/2} \\ 
&\quad \cdot \log\!\left(\frac{F}{K}\right) \\
    \mathrm{eps} &= 1E-08 \\
    \mathrm{absz} &= \mathrm{abs}\left(z\right) \\
    \mathrm{rad} &= \sqrt{1 - 2 \cdot \mathrm{rho_clamped} \cdot z + z \cdot z} \\
    x(z) &= \log\left(\frac{\mathrm{rad} \\ 
&\quad + z \\ 
&\quad - \mathrm{rho_clamped}}{1 \\ 
&\quad - \mathrm{rho_clamped}}\right) \\
    \mathrm{sabr2_raw} &= \frac{z}{x(z)} \\
    \mathrm{sabr}_{2} &= \operatorname{sel}\!\left(\mathrm{absz} \\ 
&\quad < \mathrm{eps} \\ 
&\quad , 1 \\ 
&\quad , \mathrm{sabr2_raw}\right) \\
    \mathrm{alpha}_{2} &= \alpha \cdot \alpha \\
    \mathrm{nu}_{2} &= \nu \cdot \nu \\
    \mathrm{rho}_{2} &= \mathrm{rho_clamped} \cdot \mathrm{rho_clamped} \\
    \mathrm{denom} &= 1 \\ 
&\quad + \frac{\mathrm{omb}_{2}}{24} \\ 
&\quad \cdot \mathrm{lfk}_{2} \\ 
&\quad + \frac{\mathrm{omb}_{4}}{1920} \\ 
&\quad \cdot \mathrm{lfk}_{4} \\
    \mathrm{sabr}_{1} &= \frac{\alpha}{(F K)^{(1-\beta)/2} \cdot \mathrm{denom}} \\
    \mathrm{tc}_{1} &= \frac{\mathrm{omb}_{2} \\ 
&\quad \cdot \mathrm{alpha}_{2}}{24 \\ 
&\quad \cdot \mathrm{pfk}_{2}} \\
    \mathrm{tc}_{2} &= \frac{0.25 \\ 
&\quad \cdot \mathrm{rho_clamped} \\ 
&\quad \cdot \mathrm{beta_c} \\ 
&\quad \cdot \nu \\ 
&\quad \cdot \alpha}{(F K)^{(1-\beta)/2}} \\
    \mathrm{tc}_{3} &= \frac{2 \\ 
&\quad - 3 \\ 
&\quad \cdot \mathrm{rho}_{2} \\ 
&\quad \cdot \mathrm{nu}_{2}}{24} \\
    \mathrm{timeCorr} &= \mathrm{tc}_{1} + \mathrm{tc}_{2} + \mathrm{tc}_{3} \\
    \mathrm{sabr}_{3} &= 1 + \mathrm{timeCorr} \cdot T \\
    \sigma_{\mathrm{BS}} &= \mathrm{sabr}_{1} \\ 
&\quad \cdot \mathrm{sabr}_{2} \\ 
&\quad \cdot \mathrm{sabr}_{3} \\
    \sigma_{\mathrm{BS}}\left(F,K,T,\alpha,\beta,\nu,\rho\right) &= \operatorname{sel}\!\left(T \\ 
&\quad \le 0 \\ 
&\quad , 0 \\ 
&\quad , \sigma_{\mathrm{BS}}\right) \\
\end{align*}
`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — Cuda",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

def sabr_implied_black_lognormal_volatility(forward, strike, t, alpha, beta, nu,
                                            rho):
    rho_min = -0.999999
    rho_max = 0.999999
    rho_clamped = xp.maximum(rho_min, xp.minimum(rho_max, rho))
    beta0 = 0
    beta1 = 1
    beta_c = xp.maximum(beta0, xp.minimum(beta1, beta))
    omb = (1 - beta_c)
    omb2 = (omb * omb)
    omb4 = (omb2 * omb2)
    fk = (forward * strike)
    pfk = xp.power(fk, (0.5 * omb))
    pfk2 = (pfk * pfk)
    lfk = xp.log((forward / strike))
    lfk2 = (lfk * lfk)
    lfk4 = (lfk2 * lfk2)
    z = (((nu / alpha) * pfk) * lfk)
    eps = 1E-08
    absz = xp.abs(z)
    rad = xp.sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)))
    xz = xp.log((((rad + z) - rho_clamped) / (1 - rho_clamped)))
    sabr2_raw = (z / xz)
    sabr2 = (xp.where((absz < eps), 1, sabr2_raw))
    alpha2 = (alpha * alpha)
    nu2 = (nu * nu)
    rho2 = (rho_clamped * rho_clamped)
    denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)))
    sabr1 = (alpha / (pfk * denom))
    tc1 = ((omb2 * alpha2) / (24 * pfk2))
    tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk)
    tc3 = (((2 - (3 * rho2)) * nu2) / 24)
    timeCorr = ((tc1 + tc2) + tc3)
    sabr3 = (1 + (timeCorr * t))
    sigma = (sabr1 * (sabr2 * sabr3))
    return (xp.where((t <= 0), 0, sigma))

`
    },
    {
      id: "tpl-Python-Simple",
      language: "Python",
      variant: "Simple",
      title: "Python — Simple",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def sabr_implied_black_lognormal_volatility(forward, strike, t, alpha, beta, nu,
                                            rho):
    rho_min = -0.999999
    rho_max = 0.999999
    rho_clamped = max(rho_min, min(rho_max, rho))
    beta0 = 0
    beta1 = 1
    beta_c = max(beta0, min(beta1, beta))
    omb = (1 - beta_c)
    omb2 = (omb * omb)
    omb4 = (omb2 * omb2)
    fk = (forward * strike)
    pfk = pow(fk, (0.5 * omb))
    pfk2 = (pfk * pfk)
    lfk = math.log((forward / strike))
    lfk2 = (lfk * lfk)
    lfk4 = (lfk2 * lfk2)
    z = (((nu / alpha) * pfk) * lfk)
    eps = 1E-08
    absz = abs(z)
    rad = math.sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)))
    xz = math.log((((rad + z) - rho_clamped) / (1 - rho_clamped)))
    sabr2_raw = (z / xz)
    sabr2 = (1 if (absz < eps) else sabr2_raw)
    alpha2 = (alpha * alpha)
    nu2 = (nu * nu)
    rho2 = (rho_clamped * rho_clamped)
    denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)))
    sabr1 = (alpha / (pfk * denom))
    tc1 = ((omb2 * alpha2) / (24 * pfk2))
    tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk)
    tc3 = (((2 - (3 * rho2)) * nu2) / 24)
    timeCorr = ((tc1 + tc2) + tc3)
    sabr3 = (1 + (timeCorr * t))
    sigma = (sabr1 * (sabr2 * sabr3))
    return (0 if (t <= 0) else sigma)

`
    },
    {
      id: "tpl-Python-TensorMatrixMath",
      language: "Python",
      variant: "TensorMatrixMath",
      title: "Python — TensorMatrixMath",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def sabr_implied_black_lognormal_volatility(forward, strike, t, alpha, beta, nu,
                                            rho):
    rho_min = -0.999999
    rho_max = 0.999999
    rho_clamped = max(rho_min, min(rho_max, rho))
    beta0 = 0
    beta1 = 1
    beta_c = max(beta0, min(beta1, beta))
    omb = (1 - beta_c)
    omb2 = (omb * omb)
    omb4 = (omb2 * omb2)
    fk = (forward * strike)
    pfk = pow(fk, (0.5 * omb))
    pfk2 = (pfk * pfk)
    lfk = math.log((forward / strike))
    lfk2 = (lfk * lfk)
    lfk4 = (lfk2 * lfk2)
    z = (((nu / alpha) * pfk) * lfk)
    eps = 1E-08
    absz = abs(z)
    rad = math.sqrt(((1 - (2 * (rho_clamped * z))) + (z * z)))
    xz = math.log((((rad + z) - rho_clamped) / (1 - rho_clamped)))
    sabr2_raw = (z / xz)
    sabr2 = (1 if (absz < eps) else sabr2_raw)
    alpha2 = (alpha * alpha)
    nu2 = (nu * nu)
    rho2 = (rho_clamped * rho_clamped)
    denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)))
    sabr1 = (alpha / (pfk * denom))
    tc1 = ((omb2 * alpha2) / (24 * pfk2))
    tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk)
    tc3 = (((2 - (3 * rho2)) * nu2) / 24)
    timeCorr = ((tc1 + tc2) + tc3)
    sabr3 = (1 + (timeCorr * t))
    sigma = (sabr1 * (sabr2 * sabr3))
    return (0 if (t <= 0) else sigma)

`
    },
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — Cuda",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn sabr_implied_black_lognormal_volatility(forward: f64, strike: f64, t: f64,
                                           alpha: f64, beta: f64, nu: f64,
                                           rho: f64) -> f64 {
    let mut rho_min = -0.999999;
    let mut rho_max = 0.999999;
    let mut rho_clamped: f64 = (rho_min).max((rho_max).min(rho));
    let mut beta0 = 0;
    let mut beta1 = 1;
    let mut beta_c: f64 = (beta0).max((beta1).min(beta));
    let mut omb = (1 - beta_c);
    let mut omb2 = (omb * omb);
    let mut omb4 = (omb2 * omb2);
    let mut fk = (forward * strike);
    let mut pfk: f64 = (fk).powf((0.5 * omb));
    let mut pfk2 = (pfk * pfk);
    let mut lfk: f64 = ((forward / strike)).ln();
    let mut lfk2 = (lfk * lfk);
    let mut lfk4 = (lfk2 * lfk2);
    let mut z = (((nu / alpha) * pfk) * lfk);
    let mut eps = 1E-08;
    let mut absz: f64 = (z).abs();
    let mut rad: f64 = (((1 - (2 * (rho_clamped * z))) + (z * z))).sqrt();
    let mut xz: f64 = ((((rad + z) - rho_clamped) / (1 - rho_clamped))).ln();
    let mut sabr2_raw = (z / xz);
    let mut sabr2: f64 = (if (absz < eps) { 1 } else { sabr2_raw });
    let mut alpha2 = (alpha * alpha);
    let mut nu2 = (nu * nu);
    let mut rho2 = (rho_clamped * rho_clamped);
    let mut denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    let mut sabr1 = (alpha / (pfk * denom));
    let mut tc1 = ((omb2 * alpha2) / (24 * pfk2));
    let mut tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    let mut tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    let mut timeCorr = ((tc1 + tc2) + tc3);
    let mut sabr3 = (1 + (timeCorr * t));
    let mut sigma = (sabr1 * (sabr2 * sabr3));
    return (if (t <= 0) { 0 } else { sigma });
}

`
    },
    {
      id: "tpl-Rust-Simple",
      language: "Rust",
      variant: "Simple",
      title: "Rust — Simple",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn sabr_implied_black_lognormal_volatility(forward: f64, strike: f64, t: f64,
                                           alpha: f64, beta: f64, nu: f64,
                                           rho: f64) -> f64 {
    let mut rho_min = -0.999999;
    let mut rho_max = 0.999999;
    let mut rho_clamped: f64 = (rho_min).max((rho_max).min(rho));
    let mut beta0 = 0;
    let mut beta1 = 1;
    let mut beta_c: f64 = (beta0).max((beta1).min(beta));
    let mut omb = (1 - beta_c);
    let mut omb2 = (omb * omb);
    let mut omb4 = (omb2 * omb2);
    let mut fk = (forward * strike);
    let mut pfk: f64 = (fk).powf((0.5 * omb));
    let mut pfk2 = (pfk * pfk);
    let mut lfk: f64 = ((forward / strike)).ln();
    let mut lfk2 = (lfk * lfk);
    let mut lfk4 = (lfk2 * lfk2);
    let mut z = (((nu / alpha) * pfk) * lfk);
    let mut eps = 1E-08;
    let mut absz: f64 = (z).abs();
    let mut rad: f64 = (((1 - (2 * (rho_clamped * z))) + (z * z))).sqrt();
    let mut xz: f64 = ((((rad + z) - rho_clamped) / (1 - rho_clamped))).ln();
    let mut sabr2_raw = (z / xz);
    let mut sabr2: f64 = (if (absz < eps) { 1 } else { sabr2_raw });
    let mut alpha2 = (alpha * alpha);
    let mut nu2 = (nu * nu);
    let mut rho2 = (rho_clamped * rho_clamped);
    let mut denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    let mut sabr1 = (alpha / (pfk * denom));
    let mut tc1 = ((omb2 * alpha2) / (24 * pfk2));
    let mut tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    let mut tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    let mut timeCorr = ((tc1 + tc2) + tc3);
    let mut sabr3 = (1 + (timeCorr * t));
    let mut sigma = (sabr1 * (sabr2 * sabr3));
    return (if (t <= 0) { 0 } else { sigma });
}

`
    },
    {
      id: "tpl-Rust-TensorMatrixMath",
      language: "Rust",
      variant: "TensorMatrixMath",
      title: "Rust — TensorMatrixMath",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn sabr_implied_black_lognormal_volatility(forward: f64, strike: f64, t: f64,
                                           alpha: f64, beta: f64, nu: f64,
                                           rho: f64) -> f64 {
    let mut rho_min = -0.999999;
    let mut rho_max = 0.999999;
    let mut rho_clamped: f64 = (rho_min).max((rho_max).min(rho));
    let mut beta0 = 0;
    let mut beta1 = 1;
    let mut beta_c: f64 = (beta0).max((beta1).min(beta));
    let mut omb = (1 - beta_c);
    let mut omb2 = (omb * omb);
    let mut omb4 = (omb2 * omb2);
    let mut fk = (forward * strike);
    let mut pfk: f64 = (fk).powf((0.5 * omb));
    let mut pfk2 = (pfk * pfk);
    let mut lfk: f64 = ((forward / strike)).ln();
    let mut lfk2 = (lfk * lfk);
    let mut lfk4 = (lfk2 * lfk2);
    let mut z = (((nu / alpha) * pfk) * lfk);
    let mut eps = 1E-08;
    let mut absz: f64 = (z).abs();
    let mut rad: f64 = (((1 - (2 * (rho_clamped * z))) + (z * z))).sqrt();
    let mut xz: f64 = ((((rad + z) - rho_clamped) / (1 - rho_clamped))).ln();
    let mut sabr2_raw = (z / xz);
    let mut sabr2: f64 = (if (absz < eps) { 1 } else { sabr2_raw });
    let mut alpha2 = (alpha * alpha);
    let mut nu2 = (nu * nu);
    let mut rho2 = (rho_clamped * rho_clamped);
    let mut denom = (1 + (((omb2 / 24) * lfk2) + ((omb4 / 1920) * lfk4)));
    let mut sabr1 = (alpha / (pfk * denom));
    let mut tc1 = ((omb2 * alpha2) / (24 * pfk2));
    let mut tc2 = ((((0.25 * (rho_clamped * beta_c)) * nu) * alpha) / pfk);
    let mut tc3 = (((2 - (3 * rho2)) * nu2) / 24);
    let mut timeCorr = ((tc1 + tc2) + tc3);
    let mut sabr3 = (1 + (timeCorr * t));
    let mut sigma = (sabr1 * (sabr2 * sabr3));
    return (if (t <= 0) { 0 } else { sigma });
}

`
    }
  ]
};
