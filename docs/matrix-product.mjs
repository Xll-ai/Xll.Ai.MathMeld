// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "matrix-product",
  title: "Matrix Product — Rosetta Pack",
  tags: ["linalg"],
  snippets: [
    {
      id: "tpl-C-Simple",
      language: "C",
      variant: "Simple",
      title: "C — Simple",
      code: String.raw`// expects math_runtime.h to define erf_impl, cdf_impl, print_fixed
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "math_runtime.h"

double simple_product_sum(double* b, double* c, double* y, double m, double n,
                          double j);

double simple_product_sum(double* b, double* c, double* y, double m, double n,
                          double j {
    double product = 1;
    for (int i = 0; i < m; i++) {
        product = (product * ((b)[(int)(((i * n) + j))] * (c)[(int)(((i * n) + j))]));
    }
    double sum = 0;
    for (int k = 0; k < len_impl(y); k++) {
        sum = (sum + (y)[(int)(k)]);
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-CPlusPlus-Simple",
      language: "CPlusPlus",
      variant: "Simple",
      title: "CPlusPlus — Simple",
      code: String.raw`#include <cmath>
#include <cstddef>
double simple_product_sum(std::vector<double> b, std::vector<double> c,
                          std::vector<double> y, double m, double n, double j) {
    auto product = 1;
    for (int i = 0; i < m; ++i) {
        product = (product * ((b) [static_cast < size_t > (((i * n) + j))] * (c)
             [static_cast < size_t > (((i * n) + j))]));
    }
    auto sum = 0;
    for (int k = 0; k < (y).size(); ++k) {
        sum = (sum + (y)[static_cast<size_t>(k)]);
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-CSharp-Simple",
      language: "CSharp",
      variant: "Simple",
      title: "CSharp — Simple",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double simple_product_sum(double b, double c, double y, double m, double n, double j){
    double product = 1;
    for (int i = (int)(0); i < (int)(m); i++){
    product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]));
    }
    double sum = 0;
    for (int k = (int)(0); k < (int)((y).Length); k++){
    sum = (sum + (y)[k]);
    }
    return (product * sum);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-CSharp-TensorMatrixMath",
      language: "CSharp",
      variant: "TensorMatrixMath",
      title: "CSharp — TensorMatrixMath",
      code: String.raw`using System;
using System.Globalization;
public static class Program {
  public static double simple_product_sum(double b, double c, double y, double m, double n, double j){
    double product = 1;
    for (int i = (int)(0); i < (int)(m); i++){
    product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]));
    }
    double sum = 0;
    for (int k = (int)(0); k < (int)((y).Length); k++){
    sum = (sum + (y)[k]);
    }
    return (product * sum);
  }
  public static void Main(){
  }
}
`
    },
    {
      id: "tpl-Go-Simple",
      language: "Go",
      variant: "Simple",
      title: "Go — Simple",
      code: String.raw`package main

// expects mathruntime package with Erf, Cdf, PrintFixed, Powi, DotProduct, VectorNorm
import (
    "math"
    "./mathruntime"
)

func simple_product_sum(b []float64, c []float64, y []float64, m float64,
                        n float64, j float64) float64 {
    product := 1
    for i := 0; i < m; i++ {
        product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]))
    }
    sum := 0
    for k := 0; k < len(y); k++ {
        sum = (sum + (y)[k])
    }
    return (product * sum)
}

`
    },
    {
      id: "tpl-Java-Simple",
      language: "Java",
      variant: "Simple",
      title: "Java — Simple",
      code: String.raw`// expects MathRuntime class with static methods erf, cdf, printFixed
import java.util.*;
import java.lang.Math;

public class GeneratedMath {
    public static double simple_product_sum(List<Double> b, List<Double> c,
                                            List<Double> y, double m, double n,
                                            double j) {
        double product = 1.0;
        for (int i = 0.0; i < m; i++) {
            product = (product * ((b) .get ((int) (((i * n) + j))) * (c) .get ((
                int) (((i * n) + j)))));
        }
        double sum = 0.0;
        for (int k = 0.0; k < MathRuntime.len(y); k++) {
            sum = (sum + (y).get((int)(k)));
        }
        return (product * sum);
    }

}
`
    },
    {
      id: "tpl-Javascript-Simple",
      language: "Javascript",
      variant: "Simple",
      title: "Javascript — Simple",
      code: String.raw`// expects math_runtime.js to define global MathRt {erf,cdf,printFixed}
function simple_product_sum(b, c, y, m, n, j){
let product = 1;
for (let i = 0; i < m; i++){
product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]));
}
let sum = 0;
for (let k = 0; k < (y).length; k++){
sum = (sum + (y)[k]);
}
return (product * sum);
}

`
    },
    {
      id: "tpl-MathJax-Simple",
      language: "MathJax",
      variant: "Simple",
      title: "MathJax — Simple",
      code: String.raw`\begin{align*}
    \mathrm{product} &= 1 \\
    \mathrm{sum} &= 0 \\
    \mathrm{simple_product_sum}\left(\mathrm{b},\mathrm{c},\mathrm{y},\mathrm{m},\mathrm{n},\mathrm{j}\right) &= \mathrm{product} \\ 
&\quad \cdot \mathrm{sum} \\
\end{align*}
`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — Cuda",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

def simple_product_sum(b, c, y, m, n, j):
    product = 1
    for i in range(0, m):
        product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]))
    sum = 0
    for k in range(0, len(y)):
        sum = (sum + (y)[k])
    return (product * sum)

`
    },
    {
      id: "tpl-Python-Simple",
      language: "Python",
      variant: "Simple",
      title: "Python — Simple",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def simple_product_sum(b, c, y, m, n, j):
    product = 1
    for i in range(0, m):
        product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]))
    sum = 0
    for k in range(0, len(y)):
        sum = (sum + (y)[k])
    return (product * sum)

`
    },
    {
      id: "tpl-Python-TensorMatrixMath",
      language: "Python",
      variant: "TensorMatrixMath",
      title: "Python — TensorMatrixMath",
      code: String.raw`# expects math_runtime module with MathRt class defining erf, cdf, print_fixed
import math
from math_runtime import MathRt

def simple_product_sum(b, c, y, m, n, j):
    product = 1
    for i in range(0, m):
        product = (product * ((b)[((i * n) + j)] * (c)[((i * n) + j)]))
    sum = 0
    for k in range(0, len(y)):
        sum = (sum + (y)[k])
    return (product * sum)

`
    },
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — Cuda",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn simple_product_sum(b: Vec<f64>, c: Vec<f64>, y: Vec<f64>, m: f64, n: f64,
                      j: f64) -> f64 {
    let mut product = 1;
    let mut i: i64 = 0;
    while i < m {
        product = (product * ((b)[((i * n) + j) as usize] * (c)[((i * n) + j) as usize]));
        i += 1;
    }
    let mut sum = 0;
    let mut k: i64 = 0;
    while k < (y).len() {
        sum = (sum + (y)[k as usize]);
        k += 1;
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-Rust-Simple",
      language: "Rust",
      variant: "Simple",
      title: "Rust — Simple",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn simple_product_sum(b: Vec<f64>, c: Vec<f64>, y: Vec<f64>, m: f64, n: f64,
                      j: f64) -> f64 {
    let mut product = 1;
    let mut i: i64 = 0;
    while i < m {
        product = (product * ((b)[((i * n) + j) as usize] * (c)[((i * n) + j) as usize]));
        i += 1;
    }
    let mut sum = 0;
    let mut k: i64 = 0;
    while k < (y).len() {
        sum = (sum + (y)[k as usize]);
        k += 1;
    }
    return (product * sum);
}

`
    },
    {
      id: "tpl-Rust-TensorMatrixMath",
      language: "Rust",
      variant: "TensorMatrixMath",
      title: "Rust — TensorMatrixMath",
      code: String.raw`// expects a math_runtime mod with erf/cdf helpers, etc.
use std::f64;

fn simple_product_sum(b: Vec<f64>, c: Vec<f64>, y: Vec<f64>, m: f64, n: f64,
                      j: f64) -> f64 {
    let mut product = 1;
    let mut i: i64 = 0;
    while i < m {
        product = (product * ((b)[((i * n) + j) as usize] * (c)[((i * n) + j) as usize]));
        i += 1;
    }
    let mut sum = 0;
    let mut k: i64 = 0;
    while k < (y).len() {
        sum = (sum + (y)[k as usize]);
        k += 1;
    }
    return (product * sum);
}

`
    }
  ]
};
