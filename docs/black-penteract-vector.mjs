// Generated by RosettaFormatter — do not edit by hand
/**
 * @typedef {Object} RosettaSnippet
 * @property {string} id
 * @property {string} language
 * @property {string} variant
 * @property {string} title
 * @property {string} code
 *
 * @typedef {Object} RosettaPack
 * @property {string} id
 * @property {string} title
 * @property {string[]=} tags
 * @property {RosettaSnippet[]} snippets
 */

export default {
  id: "black-vector",
  title: "Black (1976) — Vector/Tensor — Rosetta Pack",
  tags: ["options", "black", "vector", "tensor", "cuda", "simd"],
  snippets: [
    {
      id: "tpl-Cpp-SIMD",
      language: "CPlusPlus",
      variant: "SIMD",
      title: "C++ — SIMD base",
      code: String.raw`// C++ SIMD base
// Enable vectorization & parallel algorithms if you want:
//   -O3 -march=native                 (GCC/Clang)
//   /O2 /arch:AVX2                    (MSVC)
//   -fopenmp-simd (optional)          (GCC/Clang) for #pragma omp simd
#include <cmath>
#include <cstddef>
#include <vector>
#include <algorithm>
#include <execution>
#ifdef __has_include
#  if __has_include(<immintrin.h>)
#    include <immintrin.h>
#  endif
#endif

// (Optional) provide MathRt::cdf/erf if your code uses them, or include your runtime.
// #include "math_runtime.hpp"
// using namespace MathRt;

double bs_call(double s, double k, double t, double v) {
    auto d1 = ((log((s / k)) + (((v * v) / 2) * t)) / (v * sqrt(t)));
    auto d2 = (d1 - (v * sqrt(t)));
    auto price = ((s * cdf(d1)) - (k * cdf(d2)));
    return price;
}

double bs_put(double s, double k, double t, double v) {
    auto d1p = ((log((s / k)) + (((v * v) / 2) * t)) / (v * sqrt(t)));
    auto d2p = (d1p - (v * sqrt(t)));
    auto price = ((k * cdf((-d2p))) - (s * cdf((-d1p))));
    return price;
}

std::vector<double> black_5d(std::vector<double> S, std::vector<double> K, std::vector<double> T,
                             std::vector<double> V) {
    auto nS = (S).size();
    auto nK = (K).size();
    auto nT = (T).size();
    auto nV = (V).size();
    auto nP = 2;
    std : : vector < double > out = std : : vector < double > (((((static_cast < size_t > (nS) *
         static_cast < size_t > (nK)) * static_cast < size_t > (nT)) * static_cast < size_t > (nV))
         * static_cast < size_t > (nP)));
    for (int i = 0; i < nS; ++i) {
        for (int j = 0; j < nK; ++j) {
            for (int u = 0; u < nT; ++u) {
                for (int v = 0; v < nV; ++v) {
                    auto s = (S)[static_cast<size_t>(i)];
                    auto k = (K)[static_cast<size_t>(j)];
                    auto t = (T)[static_cast<size_t>(u)];
                    auto vv = (V)[static_cast<size_t>(v)];
                    auto callP = bs_call(s, k, t, vv);
                    auto putP = bs_put(s, k, t, vv);
                    out[((((((((static_cast < size_t > (i)) * (static_cast < size_t > (nK)) + (
                        static_cast < size_t > (j)))) * (static_cast < size_t > (nT)) + (static_cast
                         < size_t > (u)))) * (static_cast < size_t > (nV)) + (static_cast < size_t >
                         (v)))) * (static_cast < size_t > (nP)) + (static_cast < size_t > (0)))] =
                         putP;
                    out[((((((((static_cast < size_t > (i)) * (static_cast < size_t > (nK)) + (
                        static_cast < size_t > (j)))) * (static_cast < size_t > (nT)) + (static_cast
                         < size_t > (u)))) * (static_cast < size_t > (nV)) + (static_cast < size_t >
                         (v)))) * (static_cast < size_t > (nP)) + (static_cast < size_t > (1)))] =
                         callP;
                }
            }
        }
    }
    return out;
}

`
    },
    {
      id: "tpl-Rust-Cuda",
      language: "Rust",
      variant: "Cuda",
      title: "Rust — CUDA",
      code: String.raw`// Rust-CUDA (nvptx) target expected
//! Requires rustc_codegen_nvvm / rust-cuda crates in your project.
use core::f64;

#[kernel] // from rust-cuda or accel-like crates
pub unsafe fn black_prices_kernel(a: *const f64, b: *const f64, c: *mut f64, n: i32, k: i32, m: i32) {
    let i = (block_idx_y() * block_dim_y() + thread_idx_y()) as i32;
    let j = (block_idx_x() * block_dim_x() + thread_idx_x()) as i32;
    if i < n && j < m {
        let mut s = 0.0f64;
        let mut kk = 0;
        while kk < k {
            s += *a.offset((i*k + kk) as isize) * *b.offset((kk*m + j) as isize);
            kk += 1;
        }
        *c.offset((i*m + j) as isize) = s;
    }
}

fn bs_call(s: f64, k: f64, t: f64, v: f64) -> f64 {
    let mut d1 = ((((s / k)).ln() + (((v * v) / 2) * t)) / (v * (t).sqrt()));
    let mut d2 = (d1 - (v * (t).sqrt()));
    let mut price = ((s * cdf(d1)) - (k * cdf(d2)));
    return price;
}

fn bs_put(s: f64, k: f64, t: f64, v: f64) -> f64 {
    let mut d1p = ((((s / k)).ln() + (((v * v) / 2) * t)) / (v * (t).sqrt()));
    let mut d2p = (d1p - (v * (t).sqrt()));
    let mut price = ((k * cdf((-d2p))) - (s * cdf((-d1p))));
    return price;
}

fn black_5d(S: Vec<f64>, K: Vec<f64>, T: Vec<f64>, V: Vec<f64>) -> Vec<f64> {
    let mut nS: f64 = (S).len();
    let mut nK: f64 = (K).len();
    let mut nT: f64 = (T).len();
    let mut nV: f64 = (V).len();
    let mut nP = 2;
letmutout : Vec < f64 > = vec ! [0.0_f64; ((((((nS) asusize) * ((nK) asusize)) * ((nT) asusize)) * (
        (nV) asusize)) * ((nP) asusize)) ];
    let mut i: i64 = 0;
    while i < nS {
        let mut j: i64 = 0;
        while j < nK {
            let mut u: i64 = 0;
            while u < nT {
                let mut v: i64 = 0;
                while v < nV {
                    let mut s: f64 = (S)[i as usize];
                    let mut k: f64 = (K)[j as usize];
                    let mut t: f64 = (T)[u as usize];
                    let mut vv: f64 = (V)[v as usize];
                    let mut callP: f64 = bs_call(s, k, t, vv);
                    let mut putP: f64 = bs_put(s, k, t, vv);
                    out[((((((((((i) as usize)) * (((nK) as usize)) + (((j) as usize)))) * (((nT) as usize)) + (((u) as usize)))) * (((nV) as usize)) + (((v) as usize)))) * (((nP) as usize)) + (((0) as usize)))] = putP;
                    out[((((((((((i) as usize)) * (((nK) as usize)) + (((j) as usize)))) * (((nT) as usize)) + (((u) as usize)))) * (((nV) as usize)) + (((v) as usize)))) * (((nP) as usize)) + (((1) as usize)))] = callP;
                    v += 1;
                }
                u += 1;
            }
            j += 1;
        }
        i += 1;
    }
    return out;
}

`
    },
    {
      id: "tpl-Python-Cuda",
      language: "Python",
      variant: "Cuda",
      title: "Python — CUDA",
      code: String.raw`# software CUDA style: xp = cupy (GPU) or numpy (CPU fallback)
try:
    import cupy as xp
except Exception:
    import numpy as xp
import math
from math_runtime import MathRt

def bs_call(s, k, t, v):
    d1 = ((math.log((s / k)) + (((v * v) / 2) * t)) / (v * math.sqrt(t)))
    d2 = (d1 - (v * math.sqrt(t)))
    price = ((s * MathRt.cdf(d1)) - (k * MathRt.cdf(d2)))
    return price

def bs_put(s, k, t, v):
    d1p = ((math.log((s / k)) + (((v * v) / 2) * t)) / (v * math.sqrt(t)))
    d2p = (d1p - (v * math.sqrt(t)))
    price = ((k * MathRt.cdf((-d2p))) - (s * MathRt.cdf((-d1p))))
    return price

def black_5d(S, K, T, V):
    nS = len(S)
    nK = len(K)
    nT = len(T)
    nV = len(V)
    nP = 2
    out = [0.0] * (nS * nK * nT * nV * nP)
    for i in range(0, nS):
        for j in range(0, nK):
            for u in range(0, nT):
                for v in range(0, nV):
                    s = (S)[i]
                    k = (K)[j]
                    t = (T)[u]
                    vv = (V)[v]
                    callP = bs_call(s, k, t, vv)
                    putP = bs_put(s, k, t, vv)
                    out[i, j, u, v, 0] = putP
                    out[i, j, u, v, 1] = callP
    return out

`
    },
    {
      id: "tpl-CSharp-Tensor",
      language: "CSharp",
      variant: "Tensor",
      title: "C# — Tensor",
      code: String.raw`// C# Tensor base (no headers in emitter; bring your runtime here if needed)
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

using System;
using System.Globalization;
public static class Program {
  public static double bs_call(double s, double k, double t, double v){
    double d1 = ((Math.Log((s / k)) + (((v * v) / 2) * t)) / (v * Math.Sqrt(t)));
    double d2 = (d1 - (v * Math.Sqrt(t)));
    double price = ((s * MathRt.Cdf(d1)) - (k * MathRt.Cdf(d2)));
    return price;
  }
  public static double bs_put(double s, double k, double t, double v){
    double d1p = ((Math.Log((s / k)) + (((v * v) / 2) * t)) / (v * Math.Sqrt(t)));
    double d2p = (d1p - (v * Math.Sqrt(t)));
    double price = ((k * MathRt.Cdf((-d2p))) - (s * MathRt.Cdf((-d1p))));
    return price;
  }
  public static void black_5d(double S, double K, double T, double V){
    double nS = (S).Length;
    double nK = (K).Length;
    double nT = (T).Length;
    double nV = (V).Length;
    double nP = 2;
    double out = new double[nS * nK * nT * nV * nP];
    for (int i = (int)(0); i < (int)(nS); i++){
    for (int j = (int)(0); j < (int)(nK); j++){
    for (int u = (int)(0); u < (int)(nT); u++){
    for (int v = (int)(0); v < (int)(nV); v++){
    double s = (S)[i];
    double k = (K)[j];
    double t = (T)[u];
    double vv = (V)[v];
    double callP = bs_call(s, k, t, vv);
    double putP = bs_put(s, k, t, vv);
    out[i][j][u][v][0] = putP;
    out[i][j][u][v][1] = callP;
    }
    }
    }
    }
    return out;
  }
  public static void Main(){
  }
}
`
    }
  ],
};
